[TOC]

### 一、红黑树概述

#### 1、笔记整理原则

（1）尽量画很多图来加深对list数据结构和设计的理解，**一图胜千言**。

（2）不会详细讲解所有的代码，而是讲解**代码中的关键点，关键的数据结构和关键操作，并且对一些关键的边界条件进行讲解。**

（3）只讲解关键点，让你能完全hold住的关键点。

#### 2、红黑树简单介绍

​	红黑树的本质：先比于AVL，它使用非严格的平衡来换取增删节点时候需要旋转次数的降低，任何不平衡都能在3次旋转之内搞定。

​	首先来说，红黑树是一棵二叉搜索树。（满足二叉搜索树的性质：对于任意一个节点，该节点的左孩子节点的数值小于等于该节点，该节点的元素值小于等于右孩子节点的元素值）。同时，红黑树具有以下的规则：

（1）根节点必须为黑色节点

（2）叶子节点为空，并且必须为黑色节点

（3）某个节点如果是红色节点，那么它的孩子节点必须为黑色节点。

（4）任意节点到树尾端的叶子节点（NULL）的任何路径，所包含的黑色节点数必须相同。

![](./picture/rb_tree_1.JPG)

​	**设计红黑树主要出于以下几点考虑：**

（1）首先，这是一棵比较平衡的二叉搜索树，比较平衡的意思就是说这棵树的高度是log(n)级别的（数的高度最多为2log(n)高度）方便进行元素的增删查改。（红黑树本质是一棵弱平衡二叉树）

（2）同时，红黑树因为一系列的着色规则，它没有平衡二叉树对高度限制那么严格，可能查找方面会稍稍比AVL慢一点，但相比于AVL，它们查找的效率都是log(n)级别的，只是前面的系数有区别。

（3）正因为它对树的平衡没有AVL限制得那么严格，所以，在节点删除、修改和增加方面，它相比于AVL需要更少的旋转操作，效率也高很多。

（4）正因为它出色的针对效率的设计，所以红黑树广泛应用于数据库中。

​	**红黑树常见的使用场景：**

（1）c++ stl的底层结构中，红黑树和哈希表是set 和map的底层结构

（2）着名的Linux的的进程调度完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间; 

（3）io多路复用的epoll的实现采用红黑树管理的sockfd，以支持快速的增删查改

（4）Nginx的的的中用红黑树管理定时器，因为红黑树是有序的，可以很快的得到距离当前最小的定时器;

（5）Java的的的中TreeMap中的中的实现



#### 3、红黑树与AVL的比较

​	红黑树的本质：先比于AVL，它使用非严格的平衡来换取增删节点时候需要旋转次数的降低，任何不平衡都能在3次旋转之内搞定。

​	红黑树的查询性能相比于AVL差一点点，但都是o(log n)数量级的；插入效率两者也差不多，都是o(1)；但是红黑树( o(1) )的删除操作明显优于AVL（o(log n)）。

|          | rb_tree                                                      | AVL                                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 平衡性   | 对于每个节点，左右子树的高度差绝对值小于等于1                | 节点遵循红黑着色规则，在最坏情况下，从根节点到叶子节点的最长路径为最短路径的两倍。 |
| 查找效率 | o(log (n))                                                   | o(log (n))                                                   |
| 删除效率 | o(log n) ：如果删除一个节点引起树的不平衡，最坏情况下，需要维护从被删除节点到root这条路径上的所有node的平衡性。 | o（1）：最多三次旋转                                         |
| 插入效率 | o（1）：如果插入一个节点导致树不平衡，至多需要两次旋转       | o（1）：如果插入一个节点导致树不平衡，至多需要两次旋转       |



#### 4、红黑树查找效率的数学证明

（1）定义BH(x)：x指红黑树的一个节点，BH(x)指这个x节点到叶子节点的路径上黑色节点的数量。根据上面的性质4，可以知道无论x走哪条路径到达叶子节点，BH(x)都一样。

（2）引理1：对于以节点x为根节点的子树，设子树的总的节点数量n，那么有$n ≥ 2^{BH(x)}−1$

要分2个情况来证明这个引理：

​	a.树只有黑色节点。此时根据性质4，可以知道这树是完全二叉树，完全二叉树的节点数量等于$2^h-1$，而h又等于BH(x) 。所以此种情况满足引理。

​	b.树有黑色也有红色节点。可以把这种情况视作第一种情况下的红黑树被添加了一些红色节点或者黑色节点被替换成红色节点，根据性质1-4，可知道红色节点只会导致BH(x)值不变或变小。不等式依然成立。

（3）引理2：设树的高度为h，那么有$BH(root) >= \frac{h}{2}$

​	因为红黑树的性质3“红节点的2个孩子都是黑节点”，所以使得一条路径上红节点总数最大化的方法，必然是“黑(root)-红-黑-红-······-黑-红-黑-红-黑(leaf)”，注意，最后一个必然是叶子节点，根据性质2，这个叶子节点是黑节点，所以根据这个路径排列，就可以知道红节点必然比黑节点少，反而言之，黑节点数量必然大于等于高度的二分之一。

**引出定理：任意一棵红黑树必然满足：$h≤2log_2(n+1)​$**

![](./picture/rb_tree_2.JPG)

### 二、红黑树的增删查改

#### 1、旋转操作

以右旋转为例：例如右旋节点M步骤（左旋转也是类似）

（1）将节点 M 的左孩子引用指向节点 E 的右孩子

（2）将节点 E 的右孩子引用指向节点 M，完成旋转

![](./picture/rb_tree_3.JPG)



#### 2、插入操作

​	插入的主要流程：首先找到插入位置，然后插入一个红色节点。然后对红黑树进行变色和旋转，让新的红黑树满足4个基本的性质。插入操作主要有以下四种情况：

（1）插入节点为根节点或者是其父节点为黑色

![](./picture/rb_tree_4.JPG)

![](./picture/rb_tree_5.JPG)

（2）父节点和叔叔节点是红色

N 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 N 均为红色，所有性质4被打破，此时需要进行调整。这种情况下，先将 P 和 U 的颜色染成黑色，再将 G 的颜色染成红色。此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。

![](./picture/rb_tree_6.JPG)

（3）父节点是红色，叔叔是黑色

当插入N节点是右孩子的时候，此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照左孩子节点进行处理，以恢复性质4。

![](./picture/rb_tree_7.JPG)

![](./picture/rb_tree_8.JPG)

当插入的节点是左孩子节点：

![](./picture/rb_tree_8.JPG)

**插入总结：**

​	第一种情况比较简单。第二种和第三种比较麻烦，但也有规律。就是，如果插入节点的父节点和叔叔节点是红色，那么直接把爸爸和叔叔变色；如果爸爸是红，叔叔是黑，并且插入到左孩子，那么直接右旋转，然后变色；如果如果爸爸是红，叔叔是黑，并且插入到右孩子，那么直接左旋转，然后按照左孩子处理。

![](./picture/rb_tree_9.JPG)

#### 3、删除操作

​	我们先做一些假设，方便说明。这里假设最终被删除的节点为`X`（至多只有一个孩子节点），其孩子节点为`N`，`X`的兄弟节点为`S`，`S`的左节点为 SL，右节点为 SR。接下来讨论是建立在节点 `X` 被删除，节点 `N` 替换`X`的基础上进行的。这里说明把被删除的节点`X`特地拎出来说一下的原因是防止大家误以为节点`N`会被删除，不然后面就会看不明白。

![](./picture/rb_tree_10.JPG)

如果被删除节点为红色，直接将用子节点替换之，这种情况很简单，当被删除节点为黑色的时候，情况如下（假设替代被删除位置的节点为N，其父亲为P，其兄弟为S，兄弟左儿子为SL，兄弟右儿子为SR）：



总述：虽然删除情况较多，但是实际上总的可以分为两种情况，SL,SR全为黑和SL,SR至少有一个为红。
a.  SL,SR 全为黑，分为三种情况，P红S红不存在，不符合红黑树定义

```
 1) N黑，P黑，S红，通过处理变为3),4),5)
 2) N黑，P黑，S黑，通过将S变为红，将P设置给N，递归向上进行处理
 3) N黑，P红，S黑，交换P和S的颜色，满足红黑树，处理完毕
```

下面两个属于SL和SR至少有一个为红的情况
b. SL红，SR黑，此时S必为黑，P无所谓颜色

```
4) 经过处理，以S为中心进行右旋，变为5)
```

c. SL无所谓颜色，SR红，此时S必为黑，P无所谓颜色

```
5) P的颜色给S，SR变为黑，然后以P为中心进行左旋，红黑树处理完毕
```

![](./picture/rb_tree_11.JPG)

### 三、rb_tree节点设计

### 四、rb_tree迭代器

### 五、rb_tree数据结构

### 六、rb_tree构造与内存管理

### 七、rb_tree元素操作

### 八、参考博客

https://segmentfault.com/a/1190000012728513